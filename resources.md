# Ресурсы

* [Компоненты IdentityServer4 для ASP.NET Core 3.0 | Официальные продукты и услуги для IdentityServer](https://www.identityserver.com/articles/identityserver4-components-for-aspnet-core-30?__cf_chl_jschl_tk__=871e8163d4d2357c04e3e1e35fa847cc509f4251-1579988275-0-Ae4NUurGGS5NEce3BjnMkAsl8Pvoqpi1n87geENwlRZhH7nC1ZeIhci7o94fLg1jhxs8V1-DkmDyoHjFBHUp7uHh3Pnl-rhnK2NxESy5hVSbnmOyS_wumYCGSrMwauDaA5FsDTWtRkWbGDRJnZD4oaJSdDs-MKqmHwQ4Iko4WpW1EeLX1krAZ8SS1M4iP9uW35mcr8PYcd6TSXrQdk1TgeOAYo2u9MQIQYVPzmjkhp-OWcF5Bh6BMfhZUgkbZuuPbalSSqrvUBCoMzmaV2_sjCsYgse0meg-jMYxWJwR_cZsJRl8CF1E28-wrHELXBbLsSDhzf_cksaYE1Ek8ZQGpFTJ-QSXV36sirHEwraXrw-zGUOl5gtCHzSqliuV4oPF7lMKLvjBMSknPPQiLgwf-d8)

* [Добро пожаловать в IdentityServer4 (последняя версия) - документация по IdentityServer4 1.0.0](http://docs.identityserver.io/en/latest/)

* [Имплементация OpenId Connect в ASP.NET Core при помощи IdentityServer4 и oidc-client / Хабр](https://habr.com/ru/post/337784/)

* [ASP.NET Identity | Использование OpenID и OAuth](https://professorweb.ru/my/ASP_NET/identity/level1/1_10.php)

Схемы работы OpenId и OAuth. Microsoft.Owin.Security.OAuth - Аутентифкация через любые сервисы, поддерживающие OAuth 2.0  Примеры программирования OAuth на С#

* [Реализация OAuth 2.0 и OpenID Connect в C # (Authlete)](https://medium.com/@darutk/oauth-2-0-and-openid-connect-implementation-in-c-authlete-8a8f9efc9361)

* [Иллюстрированное руководство по OAuth и OpenID Connect / Блог компании Флант / Хабр](https://habr.com/ru/company/flant/blog/475942/)

2019г. Описание алгоритма, как сторонне приложение может действовать от имени пользователя, получив санкционированный пользовптелем доступ к его списку контактов. При этом приложение не знает пароля пользователя, а верефицируется через сервер авторизации по 
OAuth 2.0.

OpenID Connect (OIDC) — это тонкий слой поверх OAuth 2.0, добавляющий сведения о логине и профиле пользователя, который вошел в учетную запись. OpenID Connect позволяет реализовывать сценарии, когда единственный логин можно использовать во множестве приложений, — этот подход также известен как single sign-on(SSO)


* [Авторизация доступа к веб-приложениям с помощью OpenID Connect Connect & Azure AD | Microsoft Docs](https://docs.microsoft.com/ru-ru/azure/active-directory/develop/v1-protocols-openid-connect-code)

Описание протокола для Azure AD

* [Разница между OpenID и OAuth](https://softwaremaniacs.org/blog/2011/07/14/openid-oauth-difference/)

2011г. 
OpenID позволяет сайту удостовериться, что его пользователь владеет неким персональным URL (своим сайтом, блогом, профилем). Этого факта достаточно для того, чтобы использовать уникальный URL для узнавания того же самого пользователя в следующий раз. И всё. Все остальные вещи — заведение аккаунта, получение email'а и других данных, разрешение какой-то активности на сайте — остаётся на усмотрение сайта. Другими словами, OpenID — это чистая 00аутентификация: вы знаете, кто к вам пришёл, но вольны делать с этим знанием всё, что угодно.

OAuth позволяет программе (на вебе или локальной) получить от пользователя права на использование какого-то конкретного API. Права обозначаются токеном, свойства которого никак не определены: он может быть одинаковым для разных пользователей, может быть разным для одного в разное время. Всё, что гарантируется — это что программа в обмен на токен сможет выполнять какие-то действия на каком-то сервисе. Другими словами, OAuth — это чистая авторизация: вы обладаете конкретными правами, но не можете в общем случае по ним определить, кому они принадлежат.

Аналогия. OpenID — это ваш паспорт: он говорит, кто вы, но что он даёт, зависит от места, куда вы с ним пришли. OAuth — ключи от вашей машины: с ними можно ездить на вашей машине, даже не зная, как вас зовут.


* [OpenID — Википедия](https://ru.m.wikipedia.org/wiki/OpenID)

OpenID — открытый стандарт децентрализованной системы аутентификации, предоставляющей пользователю возможность создать единую учётную запись для аутентификации на множестве не связанных друг с другом интернет-ресурсов, используя услуги третьих лиц.

Аутентификацию OpenID используют в том числе Google, Yahoo!, AOL, LiveJournal, MySpace, IBM, Steam и Orange. Текущая версия стандарта, OpenID Connect 1.0, вышла в феврале 2014 года и была обновлена в ноябре 2014 года.

Стандарт не требует JavaScript или современных браузеров, однако схема аутентификации хорошо совместима с подходом AJAX. Это значит, что конечный пользователь может проходить аутентификацию на сайте, не покидая текущую страницу.

Опционально интернет-сервис и OpenID-провайдер создают общий секретный ключ для кода аутентификации сообщения по протоколу [Диффи-Хеллмана](https://ru.m.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%94%D0%B8%D1%84%D1%84%D0%B8_%E2%80%94_%D0%A5%D0%B5%D0%BB%D0%BB%D0%BC%D0%B0%D0%BD%D0%B0).

* [Введение в OAuth 2 | DigitalOcean](https://www.digitalocean.com/community/tutorials/oauth-2-ru)

OAuth 2 представляет собой фреймворк для авторизации, позволяющий приложениям осуществлять ограниченный доступ к пользовательским аккаунтам на HTTP сервисах, например, на Facebook, GitHub и DigitalOcean. Он работает по принципу делегирования аутентификации пользователя сервису, на котором находится аккаунт пользователя, позволяя стороннему приложению получать доступ к аккаунту пользователя. OAuth 2 работает в вебе, на десктопных и мобильных приложениях.

Эта статья предназначена для разработчиков приложений и предоставляет обзор ролей, типов авторизации и типичных сценариев использования OAuth 2.


* [Взлом веб-аутентификации через прокси сервер](https://resources.infosecinstitute.com/authentication-hacking-pt1/)

* [Аутентификация и авторизация в микросервисных приложениях / Блог компании DataArt / Хабр](https://habr.com/ru/company/dataart/blog/311376/)

2016г.
Как развивалась технология

1. HTTP Basic Authentication. 
man-in-the-middle attack, или атаки посредника, в ходе которой при использовании незащищенного соединения учетные данные могут перехватить злоумышленники в момент передачи от клиента к серверу или обратно. Имя пользователя и пароль передаются при каждом запросе.

2. HTTP Digest Authentication.
Использование шифрования. Подвержен атакам 

3. Forms Authentication. Форма ввода логина/пароля отправляет данные на сервер идентификации по защищенному каналу.

4. Token Authentication. Используется соцсетемя (Identity Provider), когда мы входим в приложение (Service Provider) под их учетными записями. Всегда нужен пользователь, чтобы получить доступ к ресурсу.

5. OAuth2 & Open ID Connect. Не требуется присутствие пользователя. Некоторый сервис или процесс может работать от его имени.

При обращении пользователя к клиенту, тот перенаправляет пользователя на Open ID Connect Provider, который запрашивает у пользователя логин и пароль. В случае успешного прохождения проверки параметров аутентификации он возвращает назад identity token и access token, с которыми пользователь может обращаться к защищенному ресурсу. 

Структура токенов [JWT](https://jwt.io/)


* [Сервер аутентификации Blitz Identity Provider. Единый вход, SSO, двухфакторная аутентификация.](https://identityblitz.ru/products/blitz-identity-provider/)

Поставляется в виде конечного программного продукта, устанавливается на ваш VPS под Windows или Linux. Требуется конфигурирование и администрирование.

* [Как объединить авторизацию на нескольких доменах? — Хабр Q&A](https://qna.habr.com/q/436413)

Можно почитать мнения в комментариях к вопросу. Хорошее предложение - использовать сервис для доступа к домену авторизации.

* [Как установить одинаковые куки на разных доменах - Subin's Blog](https://subinsb.com/set-same-cookie-on-different-domains/)

2014г. Через тег IMG вместо картинки, вызывается страница другого сервера для установки куков. Этот способ использует Google и др.

* [Межсайтовая авторизация 2 / Хабр](https://habr.com/ru/post/80900/)

2010г. 
Через общую базу и шифрование токенов в url

* [Межсайтовая авторизация (SSO) / Хабр](https://habr.com/ru/post/64002/)

2009г. 

Вариант 1:
Алгоритм, построен на ридеректах, шифровании параметров url и куках авторизации.
Из плюсов хочу заметить что все работает с использованием обычного протокола HTTP без применения дополнительных технологий.
Минус достаточно большой и связан с авторизацией по куки: если у пользователя отключены куки или к нам зашел робот то начинается кошмар: на каждый его запрос будет 3 редиректа + создаваться новая сессия.

Вариант 2:
Через однопиксельную псевдокартинку, все домены должны знать друг друга

